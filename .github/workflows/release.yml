name: release

on:
  workflow_dispatch:
  push:
    branches: [ release ]

jobs:
# ================================
#              macOS
# ================================
  build-lay-out-codesign:
    name: Build, lay out, and codesign macOS payload
    runs-on: macos-latest
    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0 # Indicate full history so Nerdbank.GitVersioning works.

    - name: Set up dotnet
      uses: actions/setup-dotnet@v2
      with:
        dotnet-version: 6.0.201
    
    - name: Install dependencies
      run: dotnet restore

    - name: Build
      run: |
        dotnet build --configuration=MacRelease
    
    - name: Run macOS unit tests
      run: |
        dotnet test --configuration=MacRelease

    - name: Lay out payload and symbols
      run: |
        src/osx/Installer.Mac/layout.sh --configuration=MacRelease --output=payload --symbol-output=symbols

    - name: Create keychain
      env:
        CERT_BASE64: ${{ secrets.DEVELOPER_CERTIFICATE_BASE64 }}
        CERT_PASSPHRASE: ${{ secrets.DEVELOPER_CERTIFICATE_PASSWORD }}
      run: |
        security create-keychain -p pwd $RUNNER_TEMP/buildagent.keychain
        security default-keychain -s $RUNNER_TEMP/buildagent.keychain
        security unlock-keychain -p pwd $RUNNER_TEMP/buildagent.keychain
        echo $CERT_BASE64 | base64 -D > $RUNNER_TEMP/cert.p12
        security import $RUNNER_TEMP/cert.p12 -k $RUNNER_TEMP/buildagent.keychain -P $CERT_PASSPHRASE -T /usr/bin/codesign
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k pwd $RUNNER_TEMP/buildagent.keychain
    
    - name: Run codesign
      run: |
        .github/run_macos_signing.sh payload U97A56Q9MW $GITHUB_WORKSPACE/src/osx/Installer.Mac/entitlements.xml

    - name: Upload payload
      uses: actions/upload-artifact@v2
      with:
        name: macos-payload
        path: payload
    
    - name: Upload symbols
      uses: actions/upload-artifact@v2
      with:
        name: macos-symbols
        path: symbols
  
  sign-payload:
    name: Sign macOS payload
    # ESRP service requires signing to run on Windows
    runs-on: windows-latest
    needs: build-lay-out-codesign
    steps:
    - name: Check out repository
      uses: actions/checkout@v3

    - name: Download payload
      uses: actions/download-artifact@v2
      with:
        name: macos-payload
        path: payload
    
    - name: Zip unsigned payload
      shell: pwsh
      run: |
        Compress-Archive -Path payload payload/payload.zip
        cd payload
        Get-ChildItem -Exclude payload.zip | Remove-Item -Recurse -Force
    
    - uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Install ESRP client
      shell: pwsh
      env:
        AZ_KEY: ${{ secrets.AZURE_STORAGE_KEY }}
      run: |
        az storage blob download --file esrp.zip --account-key "$env:AZ_KEY" --account-name gcmesrp --container microsoft-esrp-client --name microsoft.esrpclient.1.2.76.nupkg
        Expand-Archive -Path esrp.zip -DestinationPath .\esrp
    
    - name: Install certificates
      shell: pwsh
      env:
        AZ_VAULT: ${{ secrets.AZURE_VAULT }}
        AUTH_CERT: ${{ secrets.AZURE_VAULT_AUTH_CERT_NAME }}
        REQUEST_SIGNING_CERT: ${{ secrets.AZURE_VAULT_REQUEST_SIGNING_CERT_NAME }}
      run: |
        az keyvault secret download --vault-name "$env:AZ_VAULT" --name "$env:AUTH_CERT" --file out.pfx
        certutil -f -importpfx out.pfx
        Remove-Item out.pfx

        az keyvault secret download --vault-name "$env:AZ_VAULT" --name "$env:REQUEST_SIGNING_CERT" --file out.pfx
        certutil -f -importpfx out.pfx
        Remove-Item out.pfx
    
    - name: Run ESRP client
      shell: pwsh
      env:
        AZURE_AAD_ID: ${{ secrets.AZURE_AAD_ID }}
        # We temporarily need two AAD IDs, as we're using an SSL certificate associated
        # with an older App Registration until we have the required hardware to approve
        # the new certificate in SSL Admin.
        AZURE_AAD_ID_TEMP: ${{ secrets.AAD_ID_TEMP }}
        APPLE_KEY_CODE: ${{ secrets.APPLE_KEY_CODE }}
        APPLE_SIGNING_OP_CODE: ${{ secrets.APPLE_SIGNING_OPERATION_CODE }}
      run: |
        python .github\run_esrp_signing.py payload $env:APPLE_KEY_CODE $env:APPLE_SIGNING_OP_CODE --params 'Hardening' '--options=runtime'
    
    - name: Unzip payload
      shell: pwsh
      run: |
        Expand-Archive signed/payload.zip -DestinationPath signed
        Remove-Item signed/payload.zip

    - name: Upload signed payload
      uses: actions/upload-artifact@v2
      with:
        name: macos-signed-payload
        path: |
          signed
  
  pack:
    name: Package macOS payload
    runs-on: macos-latest
    needs: sign-payload
    steps:
    - name: Check out repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0 # Indicate full history so Nerdbank.GitVersioning works.

    - name: Set up dotnet
      uses: actions/setup-dotnet@v2
      with:
        dotnet-version: 6.0.201
    
    # Install Nerdbank.GitVersioning
    - uses: dotnet/nbgv@master
      with:
        setCommonVars: true

    - name: Download signed payload
      uses: actions/download-artifact@v2
      with:
        name: macos-signed-payload
        path: payload
    
    - name: Create component package
      run: |
        src/osx/Installer.Mac/pack.sh --payload=payload --version=$GitBuildVersionSimple --output=components/com.github.gitcredentialmanager
    
    - name: Create product archive
      run: |
        src/osx/Installer.Mac/dist.sh --package-path=components --version=$GitBuildVersionSimple --output=pkg/gcm-osx-$GitBuildVersionSimple.pkg || exit 1
    
    - name: Upload package
      uses: actions/upload-artifact@v2
      with:
        name: macos-unsigned-pkg
        path: |
          pkg
  
  sign-and-notarize-macos:
    name: Sign and notarize macOS package file
    # ESRP service requires signing to run on Windows
    runs-on: windows-latest
    needs: pack
    steps:
    - name: Check out repository
      uses: actions/checkout@v3

    - name: Download unsigned package file
      uses: actions/download-artifact@v2
      with:
        name: macos-unsigned-pkg
        path: pkg
    
    - name: Zip unsigned package file
      shell: pwsh
      run: |
        Compress-Archive -Path pkg/*.pkg pkg/gcm-pkg.zip
        cd pkg
        Get-ChildItem -Exclude gcm-pkg.zip | Remove-Item -Recurse -Force
    
    - uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Install ESRP client
      shell: pwsh
      env:
        AZ_KEY: ${{ secrets.AZURE_STORAGE_KEY }}
      run: |
        az storage blob download --file esrp.zip --account-key "$env:AZ_KEY" --account-name gcmesrp --container microsoft-esrp-client --name microsoft.esrpclient.1.2.76.nupkg
        Expand-Archive -Path esrp.zip -DestinationPath .\esrp
    
    - name: Install certificates
      shell: pwsh
      env:
        AZ_VAULT: ${{ secrets.AZURE_VAULT }}
        AUTH_CERT: ${{ secrets.AZURE_VAULT_AUTH_CERT_NAME }}
        REQUEST_SIGNING_CERT: ${{ secrets.AZURE_VAULT_REQUEST_SIGNING_CERT_NAME }}
      run: |
        az keyvault secret download --vault-name "$env:AZ_VAULT" --name "$env:AUTH_CERT" --file out.pfx
        certutil -f -importpfx out.pfx
        Remove-Item out.pfx

        az keyvault secret download --vault-name "$env:AZ_VAULT" --name "$env:REQUEST_SIGNING_CERT" --file out.pfx
        certutil -f -importpfx out.pfx
        Remove-Item out.pfx
    
    - name: Sign package file
      shell: pwsh
      env:
        AZURE_AAD_ID: ${{ secrets.AZURE_AAD_ID }}
        # We temporarily need two AAD IDs, as we're using an SSL certificate associated
        # with an older App Registration until we have the required hardware to approve
        # the new certificate in SSL Admin.
        AZURE_AAD_ID_TEMP: ${{ secrets.AAD_ID_TEMP }}
        APPLE_KEY_CODE: ${{ secrets.APPLE_KEY_CODE }}
        APPLE_SIGNING_OP_CODE: ${{ secrets.APPLE_SIGNING_OPERATION_CODE }}
      run: |
        python .github\run_esrp_signing.py pkg $env:APPLE_KEY_CODE $env:APPLE_SIGNING_OP_CODE
    
    - name: Unzip signed package file
      shell: pwsh
      run: |
        mkdir unsigned
        Expand-Archive -LiteralPath signed\gcm-pkg.zip -DestinationPath .\unsigned -Force
        Remove-Item signed\gcm-pkg.zip -Force
    
    - name: Notarize signed package file
      shell: pwsh
      env:
        AZURE_AAD_ID: ${{ secrets.AZURE_AAD_ID }}
        # We temporarily need two AAD IDs, as we're using an SSL certificate associated
        # with an older App Registration until we have the required hardware to approve
        # the new certificate in SSL Admin.
        AZURE_AAD_ID_TEMP: ${{ secrets.AAD_ID_TEMP }}
        APPLE_KEY_CODE: ${{ secrets.APPLE_KEY_CODE }}
        APPLE_NOTARIZATION_OP_CODE: ${{ secrets.APPLE_NOTARIZATION_OPERATION_CODE }}
      run: |
        python .github\run_esrp_signing.py unsigned $env:APPLE_KEY_CODE $env:APPLE_NOTARIZATION_OP_CODE --params 'BundleId' 'com.github.gitcredentialmanager'
    
    - name: Publish signed installer
      uses: actions/upload-artifact@v2
      with:
        name: macos-signed-installer

# ================================
#              Windows
# ================================
  build-and-lay-out-windows:
    name: Build and lay out Windows
    runs-on: windows-latest
    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0 # Indicate full history so Nerdbank.GitVersioning works.

    - name: Set up dotnet
      uses: actions/setup-dotnet@v2
      with:
        dotnet-version: 6.0.201

    # Install Nerdbank.GitVersioning
    - uses: dotnet/nbgv@master
      with:
        setCommonVars: true
    
    - name: Install dependencies
      run: dotnet restore

    - name: Build
      run: |
        dotnet build --configuration=WindowsRelease

    - name: Run Windows unit tests
      run: |
        dotnet test --configuration=WindowsRelease
    
    - name: Lay out
      shell: pwsh
      run: |
        mkdir windows-exes,windows-payload,windows-symbols
        Move-Item -Path out\windows\Payload.Windows\bin\Release\net472\win-x86\* -Destination windows-payload
        Move-Item -Path windows-payload\*.pdb -Destination windows-symbols
        Compress-Archive -Path windows-payload/* ./win-x86-$env:GitBuildVersionSimple.zip
        Compress-Archive -Path windows-symbols/* ./symbols-win-x86-$env:GitBuildVersionSimple.zip
        Move-Item -Path out\windows\Installer.Windows\bin\Release\net472\*.exe -Destination windows-exes

    - name: Upload artifacts
      uses: actions/upload-artifact@v2
      with:
        name: windows-artifacts
        path: |
          windows-exes
          win-x86-$env:GitBuildVersionSimple.zip
          symbols-win-x86-$env:GitBuildVersionSimple.zip

  sign-windows:
    name: Sign Windows exes
    # ESRP service requires signing to run on Windows
    runs-on: windows-latest
    needs: build-and-lay-out-windows
    steps:
    - uses: actions/checkout@v3

    - name: Download artifacts
      uses: actions/download-artifact@v2
      with:
        name: windows-artifacts
        path: artifacts

    - name: Remove timestamp file
      shell: pwsh
      run: |
        cd artifacts
        Remove-Item *.timestamp
    
    - uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Install ESRP client
      shell: pwsh
      env:
        AZ_KEY: ${{ secrets.AZURE_STORAGE_KEY }}
      run: |
        az storage blob download --file esrp.zip --account-key "$env:AZ_KEY" --account-name gcmesrp --container microsoft-esrp-client --name microsoft.esrpclient.1.2.76.nupkg
        Expand-Archive -Path esrp.zip -DestinationPath .\esrp
    
    - name: Install certificates
      shell: pwsh
      env:
        AZ_VAULT: ${{ secrets.AZURE_VAULT }}
        AUTH_CERT: ${{ secrets.AZURE_VAULT_AUTH_CERT_NAME }}
        REQUEST_SIGNING_CERT: ${{ secrets.AZURE_VAULT_REQUEST_SIGNING_CERT_NAME }}
      run: |
        az keyvault secret download --vault-name "$env:AZ_VAULT" --name "$env:AUTH_CERT" --file out.pfx
        certutil -f -importpfx out.pfx
        Remove-Item out.pfx
        az keyvault secret download --vault-name "$env:AZ_VAULT" --name "$env:REQUEST_SIGNING_CERT" --file out.pfx
        certutil -f -importpfx out.pfx
        Remove-Item out.pfx
    
    - name: Run ESRP client
      shell: pwsh
      env:
        AZURE_AAD_ID: ${{ secrets.AZURE_AAD_ID }}
        # We temporarily need two AAD IDs, as we're using an SSL certificate associated
        # with an older App Registration until we have the required hardware to approve
        # the new certificate in SSL Admin.
        AZURE_AAD_ID_TEMP: ${{ secrets.AAD_ID_TEMP }}
        WINDOWS_KEY_CODE: ${{ secrets.WINDOWS_KEY_CODE }}
        WINDOWS_OP_CODE: ${{ secrets.WINDOWS_OPERATION_CODE }}
      run: |
        python .github\run_esrp_signing.py artifacts/windows-exes $env:WINDOWS_KEY_CODE $env:WINDOWS_OP_CODE --params 'OpusName' 'Microsoft' 'OpusInfo' 'http://www.microsoft.com' 'FileDigest' '/fd "SHA256"' 'PageHash' '/NPH' 'TimeStamp' '/tr \"http://rfc3161.gtm.corp.microsoft.com/TSS/HttpTspServer\" /td sha256'
    
    - name: Publish final artifacts
      uses: actions/upload-artifact@v2
      with:
        name: signed-windows-installers
        path: signed

# ================================
#             Linux
# ================================
  build-and-lay-out-linux:
    name: Build and lay out Linux
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0 # Indicate full history so Nerdbank.GitVersioning works.

    - name: Setup .NET
      uses: actions/setup-dotnet@v2
      with:
        dotnet-version: 6.0.201

    - name: Install dependencies
      run: dotnet restore

    - name: Build
      run: dotnet build --configuration=LinuxRelease

    - name: Lay out
      run: |
        mkdir -p linux-artifacts/deb linux-artifacts/tar
        mv out/linux/Packaging.Linux/deb/Release/*.deb linux-artifacts/deb
        mv out/linux/Packaging.Linux/tar/Release/*.tar.gz linux-artifacts/tar

    - name: Upload artifacts
      uses: actions/upload-artifact@v2
      with:
        name: linux-artifacts
        path: |
          linux-artifacts
